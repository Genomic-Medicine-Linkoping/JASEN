---
title: "JASEN results"
author: "Region Östergötland"
date: "`r Sys.Date()`"
link-citations: true
bibliography: bibliography.bib
biblio-style: "alpha" #https://www.overleaf.com/learn/latex/Bibtex_bibliography_styles
#csl: "pnas.csl"
subject: "This is a report over JASEN results"
params:
    sample: "[ID info missing]"
    multiqc: "[Link missing to multiqc report]"
    quast: "[Link missing to quast report]"
    cgmlst: TRUE
keywords: 
  - JASEN
  - "Region Östergötland"
output:
  bookdown::html_document2:
    highlight: tango
    theme: yeti
    split_by: none # only generate a single output page
    self_contained: TRUE
    toc: yes
    toc_float: 
      collapsed: FALSE
      smooth_scroll: TRUE
      print: FALSE
    number_sections: FALSE
    code_download: FALSE
    pandoc_args: ["--top-level-division=section",
              "-V", "documentclass=report"]
---

**Sample ID: `r params$sample`**

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r include=FALSE}
library(jsonlite)
library(tidyverse)
library(DT)
library(bookdown)

dt_alise <- function(df, text_before, html_object, text_after) {
  df %>%
  datatable( 
    rownames = FALSE,
    extensions = c('FixedColumns','Buttons','KeyTable'),
    options=list(
      scrollX=TRUE,
      dom = 'tBlrpfi',
      lengthMenu = c(10, 30, 100),
      fixedColumns = list(leftColumns = 1),
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      keys = TRUE,
      pageLength = 30
      ), caption = htmltools::tags$caption(
    style = 'caption-side: bottom; text-align: center;',
    text_before , html_object, text_after)
    )
}



# Handle cases when there was no cgmlst data
if (params$cgmlst == TRUE){
  k1 <- fromJSON("cgmlst_stats.json", flatten=TRUE)
  k2 <- fromJSON("cgmlst_alleles.json", flatten=TRUE)
  k1d <- do.call(rbind.data.frame, k1)
  k2d <- do.call(rbind.data.frame, k2)
}else{
  # Produce empty df:s
  k1d <- data.frame(Date=as.Date(character()),
                 File=character(), 
                 User=character(), 
                 stringsAsFactors=FALSE)
  k2d <- data.frame(Date=as.Date(character()),
                 File=character(), 
                 User=character(), 
                 stringsAsFactors=FALSE) 
}


k3 <- fromJSON("mlst.json", flatten=TRUE)
k4 <- fromJSON("motif_report_local.json", flatten=TRUE)
k5 <- fromJSON("motif_report_nonc.json", flatten=TRUE)
k6 <- fromJSON("motif_report.json", flatten=TRUE)
k7 <- fromJSON("quast_report.json", flatten=TRUE)
k8 <- fromJSON("snp_report.json", flatten=TRUE)

k4d <- do.call(rbind.data.frame, k4)
k5d <- do.call(rbind.data.frame, k5)
k6d <- do.call(rbind.data.frame, k6)
k7d <- do.call(rbind.data.frame, k7)
k8d <- do.call(rbind.data.frame, k8)
phenos <- read_tsv("phenotypes.tsv")

```


# Cgmlst Stats

```{r echo=FALSE}
# If the dataframe is not empty, present it
if (dim(k1d)[1] != 0 & dim(k1d)[2] != 0) {
  # Remove default column names and ...
  oldnames <- do.call(rbind.data.frame, k1) %>%
    colnames()
  # ... use these instead:
  newnames <- c("EXC","INF","LNF","PLOT","NIPH","ALM","ASM")
  df <- do.call(rbind.data.frame, k1) %>%
    rename_at(vars(all_of(oldnames)), ~ newnames)
  df <- df[-1, ]
  
  df %>%
    datatable( 
      rownames = FALSE,
      extensions = c('Buttons','KeyTable'),
      options=list(
        # https://datatables.net/reference/option/dom
        dom = 'tBr',
        lengthMenu = c(10, 30, 100),
        scrollX=TRUE,
        ordering=FALSE,
        #fixedColumns = list(leftColumns = 1),
        #pageLength = 10,
        keys = TRUE
        ), caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
      'Table 1: Allele call statistics. For explanation on table headers, see: ', htmltools::tags$a(href="https://github.com/B-UMMI/chewBBACA/wiki/2.-Allele-Calling#allele-call-statistics-output-results_statisticstsv", "chewBBACA.py AlleleCall subcommand documentation"))
      )
}else{
  # If not found, print out just a plain and simple text
  cat("No cgmlst results due to missing schema in:\nhttps://www.cgmlst.org/ncs\nhttp://enterobase.warwick.ac.uk/")
}
```

# Cgmlst Alleles

```{r echo=FALSE, warning=FALSE}
# If the dataframe is not empty, present it
if (dim(k2d)[1] != 0 & dim(k2d)[2] != 0) {
  # Move first row to be the column names
  names(k2d) <- NULL
  names(k2d) <- lapply(k2d[1, ], as.character)
  k2d <- k2d[-1, ]
  
  # Transpose df
  k2d <- as_tibble(cbind(names(k2d), t(k2d)), 
                   validate = FALSE) 
  names(k2d) <- c("gene_name", "allele")
  
  k2d %>%
    datatable(
      rownames = FALSE,
      extensions = c('FixedColumns','Buttons','KeyTable'),
      options=list(
        scrollX=TRUE,
        dom = 'tBlrpfi',
        lengthMenu = c(10, 30, 100, 500),
        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
        keys = TRUE,
        pageLength = 10
        ), caption = htmltools::tags$caption(
      style = 'caption-side: bottom; text-align: center;',
      'Table 2: Detected cgmlst alleles. For detailed information on the target genes, see: ', htmltools::tags$a(href="https://www.cgmlst.org/ncs/schema/", "cgMLST.org Nomenclature Server"))
  )
}else{
  # If not found, print out just a plain and simple text
  cat("No cgmlst results due to missing schema in:\nhttps://www.cgmlst.org/ncs\nhttp://enterobase.warwick.ac.uk/")
}
```

Reference to chewBBACA: @Silva2018

# Contig files scan results against PubMLST typing schemes 

```{r echo=FALSE}
k3 %>%
  datatable(
    rownames = FALSE,
    extensions = c('FixedColumns','Buttons','KeyTable'),
    options=list(
      scrollX=TRUE,
      dom = 'tBr',
      ordering=FALSE,
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      keys = TRUE
      ), caption = htmltools::tags$caption(
    style = 'caption-side: bottom; text-align: center;',
    'Table 3: For detailed information on the target genes, see: ', htmltools::tags$a(href="https://www.cgmlst.org/ncs/schema/", "cgMLST.org Nomenclature Server"))
    )
```

Reference information: These results made use of the [PubMLST website](https://pubmlst.org/) developed by Keith Jolley [@Jolley2010] and sited at the University of Oxford. The development of that website was funded by the Wellcome Trust. The typing information was obtained using: Seemann T, [mlst](https://github.com/tseemann/mlst).

# Ariba 

## Local database motif report

This table includes both coding and non-coding sequences denoted by 1 and 0 in gene column respectively.   The determination of which were which was performed with [`ariba prepareref`](https://github.com/sanger-pathogens/ariba/wiki/Task:-prepareref) command.

```{r echo=FALSE}
handle_empties <- function(df1, df2){
  # Both dfs are empty, return the first empty one only
  if ((dim(df1)[1] == 0 & dim(df1)[2] == 0) & (dim(df2)[1] == 0 & dim(df2)[2] == 0)) {
    return(df1)
  # df1 empty, df2 has something, return df2
  }else if((dim(df1)[1] == 0 & dim(df1)[2] == 0) & (dim(df2)[1] != 0 & dim(df2)[2] != 0)){
    return(df2)
  # df2 empty, df1 has something, return df1  
  }else if((dim(df1)[1] != 0 & dim(df1)[2] != 0) & (dim(df2)[1] == 0 & dim(df2)[2] == 0)){
    return(df1)    
  }else if((dim(df1)[1] != 0 & dim(df1)[2] != 0) & (dim(df2)[1] != 0 & dim(df2)[2] != 0)){
    # Make data types to be equal between df:s
    common <- names(k4d)[names(k4d) %in% names(k5d)]
    k4d[common] <- lapply(common, function(x) {
      match.fun(paste0("as.", class(k5d[[x]])))(k4d[[x]])
    })
    return(bind_rows(k4d,k5d))
  }else{
    return(data.frame(c("Something","wrong"),c("went","!")))
  }
}

local_df <- handle_empties(k4d,k5d)
# Handle situation when there were no local resistance genes found
if (dim(local_df)[1] != 0 & dim(local_df)[2] != 0) {
  local_df %>%
  filter(pc_ident > 99) %>%
  relocate(X.ariba_ref_name, .after = var_description) %>%
  relocate(pc_ident, .after = ref_name) %>%
  mutate(phenotype = str_replace(free_text, ".+\\|\\|\\|", "")) %>%
  relocate(phenotype, .after = pc_ident) %>%
  select(-free_text) %>%
  mutate(matched2refGene = round(ref_base_assembled / ref_len, digits = 2)) %>%
  relocate(matched2refGene, .after = ref_base_assembled) %>%
  #dplyr::mutate(matched2refGene = ref_len / ref_base_assembled) %>%
  dt_alise('Table 4: Ariba run output for local antibiotics resistance genes. For detailed information on the table headers, see: ', htmltools::tags$a(href="https://github.com/sanger-pathogens/ariba/wiki/Task:-run#report-file", "ariba run subcommand output description"), '. matched2refGene column is calculated with ref_base_assembled / ref_len')
}else{
  # If not found, print out just a plain and simple text
  cat("No resistance genes defined by local db found.")
}
```

Reference to ARIBA: @Hunt2017

## Resfinder motif report

```{r echo=FALSE, warning=FALSE}
# If something was found from Resfinder
if (dim(k6d)[1] != 0 & dim(k6d)[2] != 0) {
  # Make join names homogeneous accross the two tables
  phenos$join_column = str_replace_all(phenos[["Gene_accession no."]],"\\(|\\)|\\'|-","_")
  k6d$join_column = str_replace_all(k6d$ref_name,"\\.","_")
  
  # Join phenotype information and print as a pretty table
  left_join(k6d,phenos, by=c("join_column" = "join_column")) %>%
    filter(pc_ident > 99) %>%
    relocate(X.ariba_ref_name, .after = var_description) %>%
    relocate(pc_ident, .after = ref_name) %>%
    select(-one_of(c("phenotype","join_column"))) %>%
    mutate(matched2refGene = round(ref_base_assembled / ref_len, digits = 2)) %>%
    relocate(matched2refGene, .after = ref_base_assembled) %>%
    dt_alise('Table 5: Ariba run output for resistance genes from Resfinder. For detailed information on the table headers, see: ', htmltools::tags$a(href="https://github.com/sanger-pathogens/ariba/wiki/Task:-run#report-file", "ariba run subcommand output description"), '. matched2refGene column is calculated with ref_base_assembled / ref_len')
}else{
  # If not found, return empty
  cat("No resistance genes defined in Resfinder found.")
  #k6d %>% 
  #  dt_alise('Table 5: Ariba run output for resistance genes from Resfinder. For detailed information on the table headers, see: ', htmltools::tags$a(href="https://github.com/sanger-pathogens/ariba/wiki/Task:-run#report-file", "ariba run subcommand output description"))
}
```

Reference to Resfinder: @Zankari2012

# Quast report

```{r echo=FALSE}
t(k7d) %>%
  datatable(
    rownames = FALSE,
    extensions = c('FixedColumns','Buttons','KeyTable'),
    options=list(
      scrollX=TRUE,
      ordering=FALSE,
      dom = 'tBr',
      #lengthMenu = c(10, 30, 100),
      #fixedColumns = list(leftColumns = 1),
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      keys = TRUE
      ), caption = htmltools::tags$caption(
    style = 'caption-side: bottom; text-align: center;',
    'Table 6: Output of genome assembly quality assessment tool. For detailed information on the table headers, see: ', htmltools::tags$a(href="http://quast.sourceforge.net/docs/manual.html#sec3.1.1", "QUAST manual"))
    )
```

Quast html report can be found [here](`r params$quast`). 

Reference to Quast: @Gurevich2013.

# SNP report

```{r echo=FALSE, comment=NA}
# If the dataframe is not empty, present it
if (dim(k8d)[1] != 0 & dim(k8d)[2] != 0) {
  k8d %>% 
    dt_alise('Table 7: Ariba run output for resistance genes from Resfinder. For detailed information on the table headers, see: ', htmltools::tags$a(href="https://github.com/sanger-pathogens/ariba/wiki/Task:-run#report-file", "ariba run subcommand output description"))
}else{
  # If not found, print out just a plain and simple text
  cat("No found SNPs with mlst: https://github.com/tseemann/mlst")
}

```

# MultiQC report

MultiQC report can be found [here](`r params$multiqc`). Reference to MultiQC: @Ewels2016.

# References
